//--------------------------------------------------------------------------------------------
//
// Generated by X-HDL VHDL Translator - Version 2.0.0 Feb. 1, 2011
// Mon Apr 21 2014 01:17:53
//
//      Input file      : 
//      Component name  : fpaddsub_8_23_uid2
//      Author          : 
//      Company         : 
//
//      Description     : 
//
//
//--------------------------------------------------------------------------------------------

//------------------------------------------------------------------------------
//                      FPAddSub_8_23_uid2_RightShifter
//                      (RightShifter_24_by_max_26_uid4)
// This operator is part of the Infinite Virtual Library FloPoCoLib
// All rights reserved 
// Authors: Bogdan Pasca, Florent de Dinechin (2008-2011)
//------------------------------------------------------------------------------
// Pipeline depth: 0 cycles

//------------------------------------------------------------------------------
//                           IntAdder_27_f180_uid7
//                    (IntAdderAlternative_27_f180_uid11)
// This operator is part of the Infinite Virtual Library FloPoCoLib
// All rights reserved 
// Authors: Bogdan Pasca, Florent de Dinechin (2008-2010)
//------------------------------------------------------------------------------
// Pipeline depth: 0 cycles

//Alternative

//------------------------------------------------------------------------------
//                   LZCShifter_28_to_28_counting_32_uid15
// This operator is part of the Infinite Virtual Library FloPoCoLib
// All rights reserved 
// Authors: Florent de Dinechin, Bogdan Pasca (2007)
//------------------------------------------------------------------------------
// Pipeline depth: 1 cycles

//--------------Synchro barrier, entering cycle 1----------------

//------------------------------------------------------------------------------
//                           IntAdder_34_f180_uid18
//                    (IntAdderAlternative_34_f180_uid22)
// This operator is part of the Infinite Virtual Library FloPoCoLib
// All rights reserved 
// Authors: Bogdan Pasca, Florent de Dinechin (2008-2010)
//------------------------------------------------------------------------------
// Pipeline depth: 0 cycles

//Alternative

//------------------------------------------------------------------------------
//                             FPAddSub_8_23_uid2
// This operator is part of the Infinite Virtual Library FloPoCoLib
// All rights reserved 
// Authors: Matei Istoan, Florent de Dinechin (2012)
//------------------------------------------------------------------------------
// Pipeline depth: 4 cycles

module FPAddSub_8_23_uid2(clk, rst, X, Y, Radd, Rsub);
   input             clk;
   input             rst;
   input [8+23+2:0]  X;
   input [8+23+2:0]  Y;
   output [8+23+2:0] Radd;
   output [8+23+2:0] Rsub;
   
   
   wire [32:0]       excExpFracX;
   wire [32:0]       excExpFracY;
   wire [8:0]        eXmeY;
   wire [8:0]        eYmeX;
   wire              swap;
   wire [33:0]       newX;
   reg [33:0]        newX_d1;
   wire [33:0]       newY;
   wire [7:0]        expX;
   reg [7:0]         expX_d1;
   wire [1:0]        excX;
   wire [1:0]        excY;
   wire              signX;
   wire              signY;
   wire              diffSigns;
   reg               diffSigns_d1;
   reg               diffSigns_d2;
   reg               diffSigns_d3;
   reg               diffSigns_d4;
   wire [5:0]        sXsYExnXY;
   wire [23:0]       fracY;
   wire [1:0]        excRtRAdd;
   reg [1:0]         excRtRAdd_d1;
   reg [1:0]         excRtRAdd_d2;
   reg [1:0]         excRtRAdd_d3;
   reg [1:0]         excRtRAdd_d4;
   wire [1:0]        excRtRSub;
   reg [1:0]         excRtRSub_d1;
   reg [1:0]         excRtRSub_d2;
   reg [1:0]         excRtRSub_d3;
   reg [1:0]         excRtRSub_d4;
   wire              signRAdd;
   reg               signRAdd_d1;
   reg               signRAdd_d2;
   wire              signRSub;
   reg               signRSub_d1;
   reg               signRSub_d2;
   reg               signRSub_d3;
   reg               signRSub_d4;
   wire [8:0]        expDiff;
   wire              shiftedOut;
   wire [4:0]        shiftVal;
   wire [49:0]       shiftedFracY;
   reg [49:0]        shiftedFracY_d1;
   wire              sticky;
   reg               sticky_d1;
   wire [26:0]       shiftedFracYext;
   wire [26:0]       fracYAdd;
   wire [26:0]       fracYSub;
   wire [26:0]       fracX;
   wire              cInFracAdderSub;
   wire [26:0]       fracAdderResultAdd;
   wire [26:0]       fracAdderResultSub;
   reg [26:0]        fracAdderResultSub_d1;
   wire [9:0]        extendedExp;
   wire [9:0]        extendedExpInc;
   reg [9:0]         extendedExpInc_d1;
   reg [9:0]         extendedExpInc_d2;
   wire [27:0]       fracGRSSub;
   wire [4:0]        nZerosNew;
   wire [27:0]       shiftedFracSub;
   wire [9:0]        updatedExpSub;
   wire              eqdiffsign;
   reg               eqdiffsign_d1;
   wire [33:0]       expFracSub;
   wire              stkSub;
   wire              rndSub;
   wire              grdSub;
   wire              lsbSub;
   wire              addToRoundBitSub;
   wire [33:0]       RoundedExpFracSub;
   reg [33:0]        RoundedExpFracSub_d1;
   wire [1:0]        upExcSub;
   wire [22:0]       fracRSub;
   wire [7:0]        expRSub;
   wire [1:0]        excRtEffSub;
   wire [3:0]        exExpExcSub;
   wire [1:0]        excRt2Sub;
   wire [1:0]        excRSub;
   wire [30:0]       computedRSub;
   wire [27:0]       fracGRSAdd;
   wire [23:0]       updatedFracAdd;
   wire [9:0]        updatedExpAdd;
   wire [33:0]       expFracAdd;
   wire              stkAdd;
   wire              rndAdd;
   wire              grdAdd;
   wire              lsbAdd;
   wire              addToRoundBitAdd;
   wire [33:0]       RoundedExpFracAdd;
   reg [33:0]        RoundedExpFracAdd_d1;
   wire [1:0]        upExcAdd;
   wire [22:0]       fracRAdd;
   wire [7:0]        expRAdd;
   wire [1:0]        excRtEffAdd;
   wire [3:0]        exExpExcAdd;
   wire [1:0]        excRt2Add;
   wire [1:0]        excRAdd;
   reg [1:0]         excRAdd_d1;
   reg [1:0]         excRAdd_d2;
   wire [30:0]       computedRAdd;
   reg [30:0]        computedRAdd_d1;
   reg [30:0]        computedRAdd_d2;
   
   always @(posedge clk)
      
      begin
         newX_d1 <= newX;
         expX_d1 <= expX;
         diffSigns_d1 <= diffSigns;
         diffSigns_d2 <= diffSigns_d1;
         diffSigns_d3 <= diffSigns_d2;
         diffSigns_d4 <= diffSigns_d3;
         excRtRAdd_d1 <= excRtRAdd;
         excRtRAdd_d2 <= excRtRAdd_d1;
         excRtRAdd_d3 <= excRtRAdd_d2;
         excRtRAdd_d4 <= excRtRAdd_d3;
         excRtRSub_d1 <= excRtRSub;
         excRtRSub_d2 <= excRtRSub_d1;
         excRtRSub_d3 <= excRtRSub_d2;
         excRtRSub_d4 <= excRtRSub_d3;
         signRAdd_d1 <= signRAdd;
         signRAdd_d2 <= signRAdd_d1;
         signRSub_d1 <= signRSub;
         signRSub_d2 <= signRSub_d1;
         signRSub_d3 <= signRSub_d2;
         signRSub_d4 <= signRSub_d3;
         shiftedFracY_d1 <= shiftedFracY;
         sticky_d1 <= sticky;
         fracAdderResultSub_d1 <= fracAdderResultSub;
         extendedExpInc_d1 <= extendedExpInc;
         extendedExpInc_d2 <= extendedExpInc_d1;
         eqdiffsign_d1 <= eqdiffsign;
         RoundedExpFracSub_d1 <= RoundedExpFracSub;
         RoundedExpFracAdd_d1 <= RoundedExpFracAdd;
         excRAdd_d1 <= excRAdd;
         excRAdd_d2 <= excRAdd_d1;
         computedRAdd_d1 <= computedRAdd;
         computedRAdd_d2 <= computedRAdd_d1;
      end
   // Exponent difference and swap  --
   assign excExpFracX = {X[33:32], X[30:0]};
   assign excExpFracY = {Y[33:32], Y[30:0]};
   assign eXmeY = ({1'b0, X[30:23]}) - ({1'b0, Y[30:23]});
   assign eYmeX = ({1'b0, Y[30:23]}) - ({1'b0, X[30:23]});
   assign swap = (excExpFracX >= excExpFracY) ? 1'b0 : 
                 1'b1;
   assign newX = (swap == 1'b0) ? X : 
                 Y;
   assign newY = (swap == 1'b0) ? Y : 
                 X;
   assign expX = newX[30:23];
   assign excX = newX[33:32];
   assign excY = newY[33:32];
   assign signX = newX[31];
   assign signY = newY[31];
   assign diffSigns = signX ^ signY;
   assign sXsYExnXY = {signX, signY, excX, excY};
   assign fracY = (excY == 2'b00) ? 24'b000000000000000000000000 : 
                  ({1'b1, newY[22:0]});
   assign excRtRAdd = (sXsYExnXY == 6'b000000 || sXsYExnXY == 6'b010000 || sXsYExnXY == 6'b100000 || sXsYExnXY == 6'b110000) ? 2'b00 : 
                      (sXsYExnXY == 6'b000101 || sXsYExnXY == 6'b010101 || sXsYExnXY == 6'b100101 || sXsYExnXY == 6'b110101 || sXsYExnXY == 6'b000100 || sXsYExnXY == 6'b010100 || sXsYExnXY == 6'b100100 || sXsYExnXY == 6'b110100 || sXsYExnXY == 6'b000001 || sXsYExnXY == 6'b010001 || sXsYExnXY == 6'b100001 || sXsYExnXY == 6'b110001) ? 2'b01 : 
                      (sXsYExnXY == 6'b111010 || sXsYExnXY == 6'b001010 || sXsYExnXY == 6'b001000 || sXsYExnXY == 6'b011000 || sXsYExnXY == 6'b101000 || sXsYExnXY == 6'b111000 || sXsYExnXY == 6'b000010 || sXsYExnXY == 6'b010010 || sXsYExnXY == 6'b100010 || sXsYExnXY == 6'b110010 || sXsYExnXY == 6'b001001 || sXsYExnXY == 6'b011001 || sXsYExnXY == 6'b101001 || sXsYExnXY == 6'b111001 || sXsYExnXY == 6'b000110 || sXsYExnXY == 6'b010110 || sXsYExnXY == 6'b100110 || sXsYExnXY == 6'b110110) ? 2'b10 : 
                      2'b11;
   assign excRtRSub = (sXsYExnXY == 6'b000000 || sXsYExnXY == 6'b010000 || sXsYExnXY == 6'b100000 || sXsYExnXY == 6'b110000) ? 2'b00 : 
                      (sXsYExnXY == 6'b000101 || sXsYExnXY == 6'b010101 || sXsYExnXY == 6'b100101 || sXsYExnXY == 6'b110101 || sXsYExnXY == 6'b000100 || sXsYExnXY == 6'b010100 || sXsYExnXY == 6'b100100 || sXsYExnXY == 6'b110100 || sXsYExnXY == 6'b000001 || sXsYExnXY == 6'b010001 || sXsYExnXY == 6'b100001 || sXsYExnXY == 6'b110001) ? 2'b01 : 
                      (sXsYExnXY == 6'b001000 || sXsYExnXY == 6'b011000 || sXsYExnXY == 6'b101000 || sXsYExnXY == 6'b111000 || sXsYExnXY == 6'b000010 || sXsYExnXY == 6'b010010 || sXsYExnXY == 6'b100010 || sXsYExnXY == 6'b110010 || sXsYExnXY == 6'b001001 || sXsYExnXY == 6'b011001 || sXsYExnXY == 6'b101001 || sXsYExnXY == 6'b111001 || sXsYExnXY == 6'b000110 || sXsYExnXY == 6'b010110 || sXsYExnXY == 6'b100110 || sXsYExnXY == 6'b110110 || sXsYExnXY == 6'b101010 || sXsYExnXY == 6'b011010) ? 2'b10 : 
                      2'b11;
   assign signRAdd = ((sXsYExnXY == 6'b100000 | sXsYExnXY == 6'b010000)) ? 1'b0 : 
                     signX;
   assign signRSub = ((sXsYExnXY == 6'b000000 | sXsYExnXY == 6'b110000)) ? 1'b0 : 
                     (signX & ((~swap))) | (((~signX)) & swap);
   //-------------- cycle 0----------------
   assign expDiff = ((swap == 1'b0)) ? eXmeY : 
                    eYmeX;
   assign shiftedOut = ((expDiff >= 25)) ? 1'b1 : 
                       1'b0;
   assign shiftVal = (shiftedOut == 1'b0) ? expDiff[4:0] : 
                     5'b11010;
   		// pipelineDepth=0 maxInDelay=3.91952e-09
   FPAddSub_8_23_uid2_RightShifter RightShifterComponent(.clk(clk), .rst(rst), .R(shiftedFracY), .S(shiftVal), .X(fracY));
   //--------------Synchro barrier, entering cycle 1----------------
   assign sticky = ((shiftedFracY_d1[23:0] == 24'b000000000000000000000000)) ? 1'b0 : 
                   1'b1;
   //-------------- cycle 0----------------
   //--------------Synchro barrier, entering cycle 1----------------
   assign shiftedFracYext = {1'b0, shiftedFracY_d1[49:24]};
   assign fracYAdd = shiftedFracYext;
   assign fracYSub = shiftedFracYext ^ 27'b111111111111111111111111111;
   assign fracX = {2'b01, (newX_d1[22:0]), 2'b00};
   assign cInFracAdderSub = (~sticky);
   		// pipelineDepth=0 maxInDelay=1.69388e-09
   IntAdder_27_f180_uid7 fracAdderAdd(.clk(clk), .rst(rst), .Cin(1'b0), .R(fracAdderResultAdd), .X(fracX), .Y(fracYAdd));
   		// pipelineDepth=0 maxInDelay=1.69388e-09
   IntAdder_27_f180_uid7 fracAdderSub(.clk(clk), .rst(rst), .Cin(cInFracAdderSub), .R(fracAdderResultSub), .X(fracX), .Y(fracYSub));
   //-------------- cycle 1----------------
   assign extendedExp = {2'b00, expX_d1};
   assign extendedExpInc = ({2'b00, expX_d1}) + 1'b1;
   //--------------Synchro barrier, entering cycle 2----------------
   assign fracGRSSub = {fracAdderResultSub_d1, sticky_d1};
   		// pipelineDepth=1 maxInDelay=7.6616e-10
   LZCShifter_28_to_28_counting_32_uid15 LZC_component(.clk(clk), .rst(rst), .Count(nZerosNew), .I(fracGRSSub), .O(shiftedFracSub));
   //--------------Synchro barrier, entering cycle 3----------------
   assign updatedExpSub = extendedExpInc_d2 - ({5'b00000, nZerosNew});
   assign eqdiffsign = (nZerosNew == 5'b11111) ? 1'b1 : 
                       1'b0;
   //-------------- cycle 3----------------
   assign expFracSub = {updatedExpSub, shiftedFracSub[26:3]};
   //-------------- cycle 3----------------
   assign stkSub = shiftedFracSub[1] | shiftedFracSub[0];
   assign rndSub = shiftedFracSub[2];
   assign grdSub = shiftedFracSub[3];
   assign lsbSub = shiftedFracSub[4];
   //-------------- cycle 3----------------
   assign addToRoundBitSub = ((lsbSub == 1'b0 & grdSub == 1'b1 & rndSub == 1'b0 & stkSub == 1'b0)) ? 1'b0 : 
                             1'b1;
   		// pipelineDepth=0 maxInDelay=3.4816e-09
   IntAdder_34_f180_uid18 roundingAdderSub(.clk(clk), .rst(rst), .Cin(addToRoundBitSub), .R(RoundedExpFracSub), .X(expFracSub), .Y(34'b0000000000000000000000000000000000));
   //--------------Synchro barrier, entering cycle 4----------------
   assign upExcSub = RoundedExpFracSub_d1[33:32];
   assign fracRSub = RoundedExpFracSub_d1[23:1];
   assign expRSub = RoundedExpFracSub_d1[31:24];
   assign excRtEffSub = ((diffSigns_d4 == 1'b1)) ? excRtRAdd_d4 : 
                        excRtRSub_d4;
   assign exExpExcSub = {upExcSub, excRtEffSub};
   assign excRt2Sub = ((exExpExcSub) == 4'b0000 || (exExpExcSub) == 4'b0100 || (exExpExcSub) == 4'b1000 || (exExpExcSub) == 4'b1100 || (exExpExcSub) == 4'b1001 || (exExpExcSub) == 4'b1101) ? 2'b00 : 
                      ((exExpExcSub) == 4'b0001) ? 2'b01 : 
                      ((exExpExcSub) == 4'b0010 || (exExpExcSub) == 4'b0110 || (exExpExcSub) == 4'b0101) ? 2'b10 : 
                      2'b11;
   assign excRSub = ((eqdiffsign_d1 == 1'b1)) ? 2'b00 : 
                    excRt2Sub;
   assign computedRSub = {expRSub, fracRSub};
   assign Rsub = ((diffSigns_d4 == 1'b0)) ? {excRSub, signRSub_d4, computedRSub} : 
                 {excRAdd_d2, signRSub_d4, computedRAdd_d2};
   //-------------- cycle 1----------------
   assign fracGRSAdd = {fracAdderResultAdd, sticky};
   assign updatedFracAdd = ((fracAdderResultAdd[26] == 1'b1)) ? fracGRSAdd[26:3] : 
                           fracGRSAdd[25:2];
   assign updatedExpAdd = ((fracAdderResultAdd[26] == 1'b1)) ? extendedExpInc : 
                          extendedExp;
   assign expFracAdd = {updatedExpAdd, updatedFracAdd};
   //-------------- cycle 1----------------
   assign stkAdd = fracGRSAdd[1] | fracGRSAdd[0];
   assign rndAdd = fracGRSAdd[2];
   assign grdAdd = fracGRSAdd[3];
   assign lsbAdd = fracGRSAdd[4];
   assign addToRoundBitAdd = (grdAdd & rndAdd) | (grdAdd & ((~rndAdd)) & lsbAdd) | (((~grdAdd)) & rndAdd & stkAdd) | (grdAdd & ((~rndAdd)) & stkAdd);
   		// pipelineDepth=0 maxInDelay=3.4816e-09
   IntAdder_34_f180_uid18 roundingAdderAdd(.clk(clk), .rst(rst), .Cin(addToRoundBitAdd), .R(RoundedExpFracAdd), .X(expFracAdd), .Y(34'b0000000000000000000000000000000000));
   //-------------- cycle 1----------------
   //--------------Synchro barrier, entering cycle 2----------------
   assign upExcAdd = RoundedExpFracAdd_d1[33:32];
   assign fracRAdd = RoundedExpFracAdd_d1[23:1];
   assign expRAdd = RoundedExpFracAdd_d1[31:24];
   assign excRtEffAdd = ((diffSigns_d2 == 1'b0)) ? excRtRAdd_d2 : 
                        excRtRSub_d2;
   assign exExpExcAdd = {upExcAdd, excRtEffAdd};
   assign excRt2Add = ((exExpExcAdd) == 4'b0000 || (exExpExcAdd) == 4'b0100 || (exExpExcAdd) == 4'b1000 || (exExpExcAdd) == 4'b1100 || (exExpExcAdd) == 4'b1001) ? 2'b00 : 
                      ((exExpExcAdd) == 4'b0001) ? 2'b01 : 
                      ((exExpExcAdd) == 4'b0010 || (exExpExcAdd) == 4'b0110 || (exExpExcAdd) == 4'b0101) ? 2'b10 : 
                      2'b11;
   assign excRAdd = excRt2Add;
   assign computedRAdd = {expRAdd, fracRAdd};
   assign Radd = ((diffSigns_d2 == 1'b0)) ? {excRAdd, signRAdd_d2, computedRAdd} : 
                 {excRSub, signRAdd_d2, computedRSub};
   
endmodule
